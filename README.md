# Solving-TSP-for-Metric-Graphs-using-MST-Heuristic

# Some Backgorunds : 

A minimum spanning tree (MST) of an edge-weighted graph is a spanning tree whose weight (the sum of the weights of its edges) is no larger than the weight of any other spanning tree. To find the MST , there are two algorithms used. 1) Kruskal’s algorithm , 2) Prim’s algorithm. Kruskal’s algorithm is greedy algorithm And ,briefly , the way how the Kruskal’s algorithm work is by adding the edges with the lowest weight until we reach our goal. We will use in this project an approximation algorithm to solve the travelling salesman problem. And in computer science , approximation algorithms are efficient algorithms that find approximate solutions to optimization problems (in particular NP-hard problems) with provable guarantees on the distance of the returned solution to the optimal one.
# Details : 
## Data Structure 
In this project we needed two types of data structures, one of them is Vector data structure which is an array with dynamically allocated space, and because of its helpful feature , we used it to store the final solution of our program. The other data structure we used was disjoint-set data structure, which is a data structure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets. And the reason why we used it , because disjoint-sets play a key role in Kruskal's algorithm. 
## Subset Class 
In this class, we used the disjoint algorithms. Makeset, Find and Union , and Makeset operation creates a set containing only a given element in it, Find algorithm determines in which subset a particular element is in and returns a representative of that set , Union algorithm merges two different subsets into single subset and according to a condition, one representative of a set will be the representative of the other one. We also have the Kruskal algorithm in this class, and the way how it will operates in this class is : 
1.	Sort all edges in non-decreasing order of their weight 
2.	Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it. 
3.	Repeat step#2 until there are (V-1) edges in the spanning tree.
## Input , randomInputs ,  Dfs and  findUsingGreedy Operations 
In the main method , we have the necessary methods for our project and program which are Input , randomInputs , Dfs and findUsingGreedy , and as the name may indicate , we will use the Input method to prompt the user to enter some information about the graph such as the number of vertices and the elements of the adjacency matrix and we will also initialize some variables in that method. randomInput operation will create a random data for the adjacency. Dfs algorithm will find the nodes or the path of the final solution by using the DFS algorithm. Finally findUsingGreedy algorithm will gather the operations or the algorithms needed to find the final solutions and it will use the 2-approximation algorithm A.K.A greedy algorithm to find the solution to the TSP.  
## Edge and AdjacencyMatrix classess 
In this classes, there is some information needed for the graph and for the program to work properly. And both classes have constructors and getters and setters. 
## TspDynamicProgrammingIterative class
And this class I obtained it from stackoverflow ( https://stackoverflow.com/questions/33527127/dynamic-programming-approach-to-tsp-in-java ) and edit a little. And this class and the operations in this class is helpful for finding the TSP using the dynamic programming approach since it gives an optimal solution, and so we can compare it with our solution which is an approximation solution. 

# Experiment : 
We experimented our algorithms by using random dataset that was generated by using the random function from math library , and the way we did it was by generating random number of vertices for the graph and random weights for the graph. And the aim was to see how the input size will affect the runtime, and if the two algorithms (greedy algorithm and dynamic programming algorithm ) will give a different result. We run the program for a fixed time that was 3 times each with random data. And we noticed that dynamic programming algorithm took a longer time than the greedy algorithm for solving a problem with a bigger input size. However , we did not see any different between the algorithms when the input size was small. In terms of running time ,  the best algorithm is greedy algorithm. However, in terms of optimal tour length of solution, the best algorithm is dynamic programming. This is in line with our expectations and alludes to the fact that different algorithms  are better suited for different situations.


# Sample Runs: 
![image](https://user-images.githubusercontent.com/70751775/150683694-46693cc8-4856-402d-b191-50ab4709c98c.png)



